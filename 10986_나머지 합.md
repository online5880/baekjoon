# [백준 10986번] 나머지 합

- **문제 링크**: [나머지 합](https://boj.kr/10986)
- **난이도**: 골드 3
- **풀이 날짜**: 2025-02-02  

---

## 📖 문제 설명

> 수 N개 A1, A2, ..., AN이 주어진다.  
> 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.  
>
> 즉, Ai + ... + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 `(i, j)` 쌍의 개수를 구해야 한다.

---

## 📌 입력  

- 첫째 줄에 `N`과 `M`이 주어진다. (`1 ≤ N ≤ 10^6`, `2 ≤ M ≤ 10^3`)
- 둘째 줄에 `N`개의 수 `A1, A2, ..., AN`이 주어진다. (`0 ≤ Ai ≤ 10^9`)

## 📌 출력  

- 연속된 부분 구간의 합이 `M`으로 나누어 떨어지는 구간의 개수를 출력한다.

---

## 📝 코드  

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())  # 수열 크기(N), 나누는 값(M)
A = list(map(int, input().split()))  # 원본 수열

S = [0] * n  # 합 배열 (누적 합)
C = [0] * m  # 나머지별 개수 저장
answer = 0  # 정답

# 누적 합 배열 생성
for i in range(n):
    S[i] = S[i-1] + A[i]  # 현재까지의 합 계산

# 나머지 연산 수행 및 카운트 저장
for i in range(n):
    remainder = S[i] % m  # 누적 합의 나머지 계산
    if remainder == 0:  # 0~i까지 합이 M의 배수인 경우
        answer += 1
    C[remainder] += 1  # 같은 나머지 개수 증가

# 조합 계산 (같은 나머지를 가진 (i, j) 쌍 찾기)
for i in range(m):
    if C[i] > 1:
        answer += (C[i] * (C[i] - 1) // 2)  # (i, j) 쌍 계산

print(answer)
```

---

## 🔍 코드 설명  

### **1️⃣ 누적 합 배열 생성**
```python
S = [0] * n  
for i in range(n):
    S[i] = S[i-1] + A[i]  # 누적 합 계산
```
- `S[i]`는 `A[0]`부터 `A[i]`까지의 합을 저장.
- 이렇게 하면 부분합을 **O(1)** 에 구할 수 있음.

---

### **2️⃣ 나머지 카운트 배열 생성**
```python
C = [0] * m  # 나머지별 개수 저장
answer = 0  # 정답
```
- `C[i]`는 **나머지가 i인 누적 합 개수**를 저장하는 배열.

---

### **3️⃣ 나머지 연산 및 개수 카운트**
```python
for i in range(n):
    remainder = S[i] % m  # 누적 합의 나머지 계산
    if remainder == 0:  # 누적 합 자체가 M의 배수인 경우
        answer += 1
    C[remainder] += 1  # 같은 나머지 개수 증가
```
- 누적 합 `S[i]`를 `M`으로 나눠 나머지를 구함.
- `S[i] % M == 0`이면 **그 자체로 M의 배수이므로 정답 증가**.
- `C[remainder]`를 증가시켜 같은 나머지 개수를 기록.

---

### **4️⃣ 조합 공식 적용**
```python
for i in range(m):
    if C[i] > 1:
        answer += (C[i] * (C[i] - 1) // 2)  # 같은 나머지를 가진 2개를 선택
```
- 같은 나머지를 가진 인덱스 중 `(i, j)`를 선택하면 `S[j] - S[i]`가 `M`의 배수가 됨.
- 즉, `C[i]` 중 **2개를 선택하는 경우의 수**:


  $^{C[i]}C_2 = \frac{C[i] \times (C[i] - 1)}{2}$


---

## 🚀 예제 & 흐름 분석  

### **입력 예시**
```text
5 3
1 2 3 1 2
```

### **누적 합 및 나머지 계산**
| i | A[i] | 누적 합 \(S[i]\) | \( S[i] \% M \) | C[] 업데이트 |
|---|---|---|---|---|
| 0 | 1 | 1 | 1 | C[1] += 1 |
| 1 | 2 | 3 | 0 | C[0] += 1 (정답 +=1) |
| 2 | 3 | 6 | 0 | C[0] += 1 (정답 +=1) |
| 3 | 1 | 7 | 1 | C[1] += 1 |
| 4 | 2 | 9 | 0 | C[0] += 1 (정답 +=1) |

---

### **결과**
- `C[0] = 3`, `C[1] = 2`
- `(C[0] * (C[0] - 1)) // 2 = (3 * 2) // 2 = 3`
- `(C[1] * (C[1] - 1)) // 2 = (2 * 1) // 2 = 1`
- `answer = 3 + 1 + 3 = 7`

### **출력 예시**
```text
7
```

---

## 🕑 시간 복잡도 분석  

- **누적 합 배열 계산** → `O(N)`
- **나머지 카운트 배열 채우기** → `O(N)`
- **조합 계산** → `O(M)`, (`M ≤ 1000` 이므로 무시 가능)

총 시간 복잡도: **`O(N)`**, 매우 효율적! 🚀

---

## ✅ 최종 정리  

| 단계 | 설명 |
|------|------|
| **1. 누적 합 배열 생성** | `S[i] = S[i-1] + A[i]` |
| **2. 나머지 카운트 배열 채우기** | `C[S[i] % M] += 1` |
| **3. 같은 나머지 개수 조합 계산** | `C[i] * (C[i] - 1) // 2` |

**포인트:** 같은 나머지를 가진 두 개의 인덱스 `(i, j)`를 찾는 것이 핵심!

---
> 코드 설명은 GPT 도움을 받았습니다... \
> 어렵습니다 ㅠㅠ
